const fs = require('fs-extra');
const path = require('path');
const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, ImageRun, BorderStyle, Table, TableRow, TableCell, WidthType } = require('docx');
const markdownIt = require('markdown-it');
const { logger } = require('../utils/logger');

class DOCXConverter {
  constructor(options = {}) {
    this.options = {
      title: 'Document',
      author: 'FileConverter CLI',
      subject: 'Converted from Markdown',
      ...options
    };

    // Extract formatting options with defaults
    this.formatting = {
      headingSpacing: {
        before: 400,
        after: 200
      },
      paragraphSpacing: {
        before: 0,
        after: 150
      },
      sectionSpacing: {
        before: 300,
        after: 200
      },
      fontSize: 22,
      headingFontSizes: {
        h1: 32,
        h2: 28,
        h3: 24,
        h4: 22,
        h5: 20,
        h6: 18
      },
      colors: {
        headings: '000000',
        text: '000000',
        code: '0052CC'
      },
      fonts: {
        default: 'Calibri',
        code: 'Roboto'
      },
      table: {
        borderColor: '000000',
        headerBackground: 'E6E6E6',
        borderSize: 4
      },
      alignment: {
        paragraphs: 'justified',
        headings: 'left'
      },
      ...options.docx?.formatting
    };

    this.markdown = markdownIt({
      html: true,
      linkify: true,
      typographer: true,
      breaks: false
    });
  }

  getAlignmentType(alignmentString) {
    const alignmentMap = {
      'left': AlignmentType.LEFT,
      'center': AlignmentType.CENTER,
      'right': AlignmentType.RIGHT,
      'justified': AlignmentType.JUSTIFIED
    };
    return alignmentMap[alignmentString] || AlignmentType.LEFT;
  }

  async convert(markdownPath, outputPath) {
    try {
      logger.debug(`Converting ${markdownPath} to DOCX...`);

      // Read markdown content
      const markdownContent = await fs.readFile(markdownPath, 'utf-8');
      
      // Parse markdown and convert to DOCX elements
      const docElements = await this.parseMarkdownToDocx(markdownContent);
      
      // Create DOCX document
      const doc = new Document({
        sections: [{
          properties: {},
          children: docElements
        }],
        creator: this.options.author,
        title: this.options.title,
        subject: this.options.subject,
        description: 'Generated by FileConverter CLI',
        compatibility: {
          doNotAutofitConstrainedTables: true,
          autofitToFirstFixedWidthCell: false
        }
      });

      // Ensure output directory exists
      await fs.ensureDir(path.dirname(outputPath));

      // Generate DOCX buffer
      const buffer = await Packer.toBuffer(doc);
      
      // Write to file
      await fs.writeFile(outputPath, buffer);

      // Verify output file
      const stats = await fs.stat(outputPath);
      if (stats.size === 0) {
        throw new Error('Generated DOCX file is empty');
      }

      logger.debug(`DOCX file created: ${outputPath} (${this.formatFileSize(stats.size)})`);

      return {
        success: true,
        path: outputPath,
        size: stats.size
      };

    } catch (error) {
      logger.error(`DOCX conversion failed: ${error.message}`);
      
      return {
        success: false,
        error: error.message
      };
    }
  }

  async parseMarkdownToDocx(markdownContent) {
    const elements = [];
    const lines = markdownContent.split('\n');
    let currentParagraph = [];
    let inCodeBlock = false;
    let codeBlockContent = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Handle code blocks
      if (line.startsWith('```')) {
        if (inCodeBlock) {
          // End of code block
          if (codeBlockContent.length > 0) {
            const codeBlockParagraphs = this.createCodeBlock(codeBlockContent.join('\n'));
            elements.push(...codeBlockParagraphs);
            codeBlockContent = [];
          }
          inCodeBlock = false;
        } else {
          // Start of code block
          if (currentParagraph.length > 0) {
            elements.push(this.createParagraph(currentParagraph.join(' ')));
            currentParagraph = [];
          }
          inCodeBlock = true;
        }
        continue;
      }

      if (inCodeBlock) {
        codeBlockContent.push(line);
        continue;
      }

      // Handle lists FIRST (before headings) to prevent bold text in lists from being treated as headers
      if (line.match(/^\s*[-*+]\s/) || line.match(/^\s*\d+\.\s/)) {
        if (currentParagraph.length > 0) {
          elements.push(this.createParagraph(currentParagraph.join(' ')));
          currentParagraph = [];
        }
        elements.push(this.createListItem(line));
        continue;
      }

      // Handle tables (detect table rows with |)
      if (line.includes('|') && line.trim().startsWith('|') && line.trim().endsWith('|')) {
        if (currentParagraph.length > 0) {
          elements.push(this.createParagraph(currentParagraph.join(' ')));
          currentParagraph = [];
        }
        
        // Collect table rows
        const tableRows = [line];
        let nextIndex = i + 1;
        
        // Look ahead for more table rows
        while (nextIndex < lines.length) {
          const nextLine = lines[nextIndex];
          if (nextLine.includes('|') && nextLine.trim().startsWith('|') && nextLine.trim().endsWith('|')) {
            tableRows.push(nextLine);
            nextIndex++;
          } else if (nextLine.trim() === '') {
            // Skip empty lines within table
            nextIndex++;
          } else {
            break;
          }
        }
        
        // Create table
        const table = this.createTable(tableRows);
        if (table) {
          elements.push(table);
        }
        
        // Skip processed lines
        i = nextIndex - 1;
        continue;
      }

      // Handle horizontal rules (---)
      if (line.trim() === '---' || line.trim() === '***' || line.trim() === '___') {
        if (currentParagraph.length > 0) {
          elements.push(this.createParagraph(currentParagraph.join(' ')));
          currentParagraph = [];
        }
        elements.push(this.createHorizontalRule());
        continue;
      }

      // Handle headings (ONLY lines that start with #)
      if (line.startsWith('#')) {
        if (currentParagraph.length > 0) {
          elements.push(this.createParagraph(currentParagraph.join(' ')));
          currentParagraph = [];
        }
        
        // No spacing before headers - keep compact
        
        elements.push(this.createHeading(line));
        continue;
      }

      // Handle empty lines
      if (line.trim() === '') {
        if (currentParagraph.length > 0) {
          elements.push(this.createParagraph(currentParagraph.join(' ')));
          currentParagraph = [];
        }
        continue;
      }

      // Handle images (basic support)
      if (line.includes('![') && line.includes('](')) {
        if (currentParagraph.length > 0) {
          elements.push(this.createParagraph(currentParagraph.join(' ')));
          currentParagraph = [];
        }
        
        const imageElement = await this.createImage(line);
        if (imageElement) {
          elements.push(imageElement);
        }
        continue;
      }

      // Handle admonitions (like !!! warning, !!! note, etc.)
      if (line.startsWith('!!!')) {
        if (currentParagraph.length > 0) {
          elements.push(this.createParagraph(currentParagraph.join(' ')));
          currentParagraph = [];
        }
        
        // Collect admonition content
        const admonitionLines = [line];
        let nextIndex = i + 1;
        
        // Look ahead for indented content (admonition body)
        while (nextIndex < lines.length) {
          const nextLine = lines[nextIndex];
          if (nextLine.startsWith('    ') || nextLine.trim() === '') {
            admonitionLines.push(nextLine);
            nextIndex++;
          } else {
            break;
          }
        }
        
        // Create admonition
        const admonitionElements = this.createAdmonition(admonitionLines);
        elements.push(...admonitionElements);
        
        // Skip processed lines
        i = nextIndex - 1;
        continue;
      }

      // Handle blockquotes
      if (line.startsWith('>')) {
        if (currentParagraph.length > 0) {
          elements.push(this.createParagraph(currentParagraph.join(' ')));
          currentParagraph = [];
        }
        elements.push(this.createBlockquote(line.substring(1).trim()));
        continue;
      }

      // Regular paragraph content
      currentParagraph.push(line);
    }

    // Handle remaining paragraph content
    if (currentParagraph.length > 0) {
      elements.push(this.createParagraph(currentParagraph.join(' ')));
    }

    // Handle remaining code block
    if (inCodeBlock && codeBlockContent.length > 0) {
      const codeBlockParagraphs = this.createCodeBlock(codeBlockContent.join('\n'));
      elements.push(...codeBlockParagraphs);
    }

    return elements;
  }

  createHeading(line) {
    const level = line.match(/^#+/)[0].length;
    const text = line.replace(/^#+\s*/, '').trim();
    
    const headingLevels = {
      1: HeadingLevel.HEADING_1,
      2: HeadingLevel.HEADING_2,
      3: HeadingLevel.HEADING_3,
      4: HeadingLevel.HEADING_4,
      5: HeadingLevel.HEADING_5,
      6: HeadingLevel.HEADING_6
    };

    const headingLevel = Math.min(level, 6);
    const fontSizeKey = `h${headingLevel}`;
    const fontSize = this.formatting.headingFontSizes[fontSizeKey] || this.formatting.headingFontSizes.h1;

    return new Paragraph({
      children: [
        new TextRun({
          text: text,
          bold: true,
          size: fontSize,
          color: this.formatting.colors.headings,
          font: this.formatting.fonts.default
        })
      ],
      heading: headingLevels[headingLevel] || HeadingLevel.HEADING_1,
      alignment: this.getAlignmentType(this.formatting.alignment.headings),
      spacing: {
        before: 240 // Add space before header (12pt)
      },
      // Explicitly prevent any extra formatting
      style: undefined
    });
  }

  createParagraph(text) {
    // Handle basic markdown formatting
    const runs = this.parseInlineFormatting(text);
    
    // Apply default font size and color to runs that don't have specific formatting
    const formattedRuns = runs.map(run => {
      if (run.text && !run.size && !run.font) {
        return new TextRun({
          ...run,
          size: this.formatting.fontSize,
          color: this.formatting.colors.text,
          font: this.formatting.fonts.default
        });
      }
      return run;
    });
    
    return new Paragraph({
      children: formattedRuns,
      alignment: this.getAlignmentType(this.formatting.alignment.paragraphs),
      // Explicitly prevent any heading styling
      heading: undefined,
      style: undefined
    });
  }

  parseInlineFormatting(text) {
    const runs = [];
    
    // Find all markdown patterns
    const boldRegex = /\*\*(.*?)\*\*/g;
    const italicRegex = /\*([^*]+?)\*/g;
    const codeRegex = /`([^`]+?)`/g;
    
    const matches = [];
    
    // Find bold matches first
    let match;
    while ((match = boldRegex.exec(text)) !== null) {
      matches.push({
        start: match.index,
        end: match.index + match[0].length,
        content: match[1],
        type: 'bold'
      });
    }
    
    // Find italic matches (avoid conflicts with bold)
    italicRegex.lastIndex = 0;
    while ((match = italicRegex.exec(text)) !== null) {
      // Check if this italic is completely inside a bold match
      const isInsideBold = matches.some(m =>
        m.type === 'bold' &&
        match.index >= m.start &&
        (match.index + match[0].length) <= m.end
      );
      
      if (!isInsideBold) {
        matches.push({
          start: match.index,
          end: match.index + match[0].length,
          content: match[1],
          type: 'italic'
        });
      }
    }
    
    // Find code matches
    codeRegex.lastIndex = 0;
    while ((match = codeRegex.exec(text)) !== null) {
      matches.push({
        start: match.index,
        end: match.index + match[0].length,
        content: match[1],
        type: 'code'
      });
    }
    
    // Sort matches by start position
    matches.sort((a, b) => a.start - b.start);
    
    // Build runs
    let lastEnd = 0;
    for (const match of matches) {
      // Add text before this match
      if (match.start > lastEnd) {
        const beforeText = text.substring(lastEnd, match.start);
        if (beforeText) {
          runs.push(new TextRun({
            text: beforeText,
            size: this.formatting.fontSize,
            color: this.formatting.colors.text,
            font: 'Calibri'
          }));
        }
      }
      
      // Add formatted text - ensure it's always regular text, never heading
      const runOptions = {
        text: match.content,
        size: this.formatting.fontSize,
        color: this.formatting.colors.text, // Always use text color for inline formatting
        font: 'Calibri'
      };
      
      if (match.type === 'bold') {
        runOptions.bold = true;
        // Explicitly ensure bold text is not treated as heading
        runOptions.color = this.formatting.colors.text;
      } else if (match.type === 'italic') {
        runOptions.italics = true;
      } else if (match.type === 'code') {
        runOptions.font = this.formatting.fonts.code;
        runOptions.size = this.formatting.fontSize - 2;
        runOptions.color = this.formatting.colors.code;
      }
      
      runs.push(new TextRun(runOptions));
      lastEnd = match.end;
    }
    
    // Add remaining text
    if (lastEnd < text.length) {
      const remainingText = text.substring(lastEnd);
      if (remainingText) {
        runs.push(new TextRun({
          text: remainingText,
          size: this.formatting.fontSize,
          color: this.formatting.colors.text,
          font: 'Calibri'
        }));
      }
    }
    
    // If no matches found, return simple text run
    if (runs.length === 0) {
      runs.push(new TextRun({
        text: text,
        size: this.formatting.fontSize,
        color: this.formatting.colors.text,
        font: 'Calibri'
      }));
    }
    
    return runs;
  }

  createCodeBlock(content) {
    // Split content into lines and create separate paragraphs for each line
    const lines = content.split('\n');
    const paragraphs = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      paragraphs.push(new Paragraph({
        children: [
          new TextRun({
            text: line || ' ', // Use space for empty lines to maintain structure
            font: this.formatting.fonts.code,
            size: this.formatting.fontSize - 2,
            color: this.formatting.colors.code
          })
        ],
        alignment: AlignmentType.LEFT,
        shading: {
          fill: 'F5F5F5' // Light gray background for code blocks
        },
        indent: {
          left: 360, // 0.25 inch indent
          right: 360
        },
        spacing: {
          before: i === 0 ? 120 : 0, // Only add spacing before first line
          after: i === lines.length - 1 ? 120 : 0 // Only add spacing after last line
        },
        // Explicitly prevent heading styling
        heading: undefined,
        style: undefined
      }));
    }
    
    return paragraphs;
  }

  createTable(tableRows) {
    try {
      // Filter out separator rows (like |---|---|)
      const dataRows = tableRows.filter(row => !row.match(/^\|\s*[-:]+\s*\|/));
      
      if (dataRows.length === 0) {
        return null;
      }

      const rows = [];
      let isHeaderRow = true;
      let columnCount = 0;

      for (const rowText of dataRows) {
        // Parse table cells
        const cells = rowText
          .split('|')
          .slice(1, -1) // Remove first and last empty elements
          .map(cell => cell.trim());

        if (cells.length === 0) continue;

        // Set column count from first row
        if (columnCount === 0) {
          columnCount = cells.length;
        }

        // Create table cells using the simple pattern from documentation
        const tableCells = cells.map(cellText => {
          const runs = this.parseInlineFormatting(cellText);
          
          return new TableCell({
            children: [
              new Paragraph({
                children: runs,
                alignment: AlignmentType.LEFT
              })
            ],
            shading: isHeaderRow ? {
              fill: this.formatting.table.headerBackground
            } : undefined
          });
        });

        rows.push(new TableRow({
          children: tableCells
        }));

        isHeaderRow = false; // Only first row is header
      }

      // Calculate column widths in DXA - A4 page width is ~9638 DXA
      // Use 9000 DXA to leave some margin
      const totalWidth = 9000;
      const columnWidth = Math.floor(totalWidth / columnCount);
      const columnWidths = Array(columnCount).fill(columnWidth);

      // Create table using the working solution from GitHub issues
      return new Table({
        rows: rows,
        width: {
          size: 0, // AUTO width as recommended
          type: WidthType.AUTO
        },
        columnWidths: columnWidths // This is the key fix!
      });

    } catch (error) {
      logger.warn(`Failed to create table: ${error.message}`);
      return null;
    }
  }

  createHorizontalRule() {
    return new Paragraph({
      children: [
        new TextRun({
          text: '',
          size: 1
        })
      ],
      border: {
        bottom: {
          color: '000000',
          space: 1,
          style: BorderStyle.SINGLE,
          size: 6
        }
      },
      spacing: {
        before: 120,
        after: 120
      }
    });
  }

  createListItem(line) {
    const text = line.replace(/^\s*[-*+]\s/, '').replace(/^\s*\d+\.\s/, '').trim();
    
    // Apply formatting to list item text but force text color
    const runs = this.parseInlineFormatting(text);
    
    // Ensure all runs in list items use text color, not heading color
    const textColorRuns = runs.map(run => {
      if (run.bold || run.italics) {
        return new TextRun({
          text: run.text,
          bold: run.bold || false,
          italics: run.italics || false,
          font: run.font || this.formatting.fonts.default,
          size: this.formatting.fontSize,
          color: this.formatting.colors.text // Force text color for list items
        });
      }
      return run;
    });
    
    return new Paragraph({
      children: textColorRuns,
      alignment: this.getAlignmentType(this.formatting.alignment.paragraphs),
      bullet: {
        level: 0
      },
      // Explicitly prevent any heading styling for list items
      heading: undefined,
      style: undefined
    });
  }

  createAdmonition(admonitionLines) {
    const elements = [];
    
    // Parse the first line to get type and title
    const firstLine = admonitionLines[0];
    const match = firstLine.match(/^!!!\s+(\w+)(?:\s+"([^"]*)")?/);
    
    if (!match) {
      // Fallback to regular paragraph if parsing fails
      return [this.createParagraph(admonitionLines.join(' '))];
    }
    
    const [, type, title] = match;
    
    // Define admonition styles
    const admonitionStyles = {
      warning: { color: 'FF6B35', backgroundColor: 'FFF4E6', icon: '⚠️' },
      note: { color: '0066CC', backgroundColor: 'E6F3FF', icon: '📝' },
      info: { color: '17A2B8', backgroundColor: 'E6F9FC', icon: 'ℹ️' },
      tip: { color: '28A745', backgroundColor: 'E6F7E6', icon: '💡' },
      danger: { color: 'DC3545', backgroundColor: 'FFE6E6', icon: '🚨' },
      success: { color: '28A745', backgroundColor: 'E6F7E6', icon: '✅' },
      error: { color: 'DC3545', backgroundColor: 'FFE6E6', icon: '❌' }
    };
    
    const style = admonitionStyles[type.toLowerCase()] || admonitionStyles.info;
    
    // Create title paragraph
    const titleText = title || type.charAt(0).toUpperCase() + type.slice(1);
    const titleParagraph = new Paragraph({
      children: [
        new TextRun({
          text: `${style.icon} ${titleText}`,
          bold: true,
          size: this.formatting.fontSize + 2,
          color: style.color,
          font: this.formatting.fonts.default
        })
      ],
      alignment: AlignmentType.LEFT,
      shading: {
        fill: style.backgroundColor
      },
      indent: {
        left: 360,
        right: 360
      },
      spacing: {
        before: 120,
        after: 60
      },
      border: {
        left: {
          color: style.color,
          space: 1,
          style: BorderStyle.SINGLE,
          size: 12
        }
      }
    });
    
    elements.push(titleParagraph);
    
    // Process content lines (skip first line, remove indentation)
    const contentLines = admonitionLines.slice(1)
      .map(line => line.replace(/^ {4}/, '')) // Remove 4-space indentation
      .filter(line => line.trim() !== ''); // Remove empty lines
    
    if (contentLines.length > 0) {
      const contentText = contentLines.join(' ').trim();
      if (contentText) {
        const runs = this.parseInlineFormatting(contentText);
        
        const contentParagraph = new Paragraph({
          children: runs,
          alignment: AlignmentType.LEFT,
          shading: {
            fill: style.backgroundColor
          },
          indent: {
            left: 360,
            right: 360
          },
          spacing: {
            before: 0,
            after: 120
          },
          border: {
            left: {
              color: style.color,
              space: 1,
              style: BorderStyle.SINGLE,
              size: 12
            }
          }
        });
        
        elements.push(contentParagraph);
      }
    }
    
    return elements;
  }

  createBlockquote(text) {
    // Apply formatting to blockquote text
    const runs = this.parseInlineFormatting(text);
    
    // Make all runs italic (blockquote style)
    const italicRuns = runs.map(run => {
      if (run.text) {
        return new TextRun({
          text: run.text,
          italics: true,
          bold: run.bold || false,
          font: run.font || this.formatting.fonts.default,
          size: this.formatting.fontSize,
          color: this.formatting.colors.text
        });
      }
      return run;
    });
    
    return new Paragraph({
      children: italicRuns,
      alignment: AlignmentType.LEFT,
      indent: {
        left: 720 // 0.5 inch
      },
      // Explicitly prevent heading styling
      heading: undefined,
      style: undefined
    });
  }

  async createImage(line) {
    try {
      const match = line.match(/!\[(.*?)\]\((.*?)\)/);
      if (!match) return null;
      
      const [, altText, imagePath] = match;
      
      // Check if image file exists
      if (!await fs.pathExists(imagePath)) {
        logger.warn(`Image not found: ${imagePath}`);
        return new Paragraph({
          text: `[Image: ${altText}]`
        });
      }

      // Read image file
      const imageBuffer = await fs.readFile(imagePath);
      
      return new Paragraph({
        children: [
          new ImageRun({
            data: imageBuffer,
            transformation: {
              width: 400,
              height: 300
            }
          })
        ],
        alignment: AlignmentType.CENTER
      });

    } catch (error) {
      logger.warn(`Failed to process image: ${error.message}`);
      return new Paragraph({
        text: `[Image processing failed]`
      });
    }
  }

  formatFileSize(bytes) {
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    if (bytes === 0) return '0 Bytes';
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
  }

  // No longer needed - pure Node.js implementation
  async checkPandocAvailability() {
    return {
      available: true,
      version: 'native-docx-library'
    };
  }

  async validateMarkdown(markdownPath) {
    try {
      const content = await fs.readFile(markdownPath, 'utf-8');
      
      const issues = [];
      
      // Check for Mermaid diagrams
      if (content.includes('```mermaid')) {
        issues.push({
          type: 'info',
          message: 'Mermaid diagrams detected - they will be converted to images'
        });
      }
      
      return {
        valid: true,
        issues
      };
    } catch (error) {
      return {
        valid: false,
        error: error.message
      };
    }
  }
}

module.exports = { DOCXConverter };